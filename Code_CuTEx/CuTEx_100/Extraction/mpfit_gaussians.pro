function mpfit_gaussians, im, dmax, drange, windowcenter, center, ngaussians, source_par, psf_lim, $posback=posback, weight=weight, backgfit=backgfit, psf=psf, mask=mask, perr=perr, $sources=sources, verbose=verbose, rmsmap=rmsmapif not keyword_set(verbose) then quiet = 1 else quiet=0; ADDED KEYWORD FOR DIFFERENT ORDER OF POLYMONIAL FOR BACKGROUND FITTING;; COVAR = covar_ -> Covariance matrix; YFIT  = prova  -> Fitted Function. ; BESTNORM = chisum -> Square sum of residuals; PERROR = perror -> Errors on single parameters; DOF = dof -> Degrees of freedom; NO +1 offset in fitted X0,Y0 gaussian center should be added here since everything is internal to IDL, and the offset will be inserted explicitely in pixel coordinates at the time of output ; Multiple Gaussian fitting. Fit N gaussians, where N is defined by parameter ngaussians, to the image im; using the guess parameters contained in the source_par structure p;; THIS IS UNWEIGHTED FIT.;; Added: Putting the starting values of the parameters for the background plane as zero brings problems; in fitting. The intial values for the [A,B,C] parameters of the plane are now defined through a rought; plane fitting to the subimage. Thus the initial value of the central peak flux of the gaussian is given ; by the value of the subimage at the center position minus the value of the plane at the center position;; Added: The background is now computed as the value of the final fitted plane at the center position.; Since the plane is fitted in the subimage the center position should take count of the different ; zero axis position. background = a0+ b0*(center(0) - xwin1) + c0*(center(1) - ywin1);; Added: it returns also the fitting function as a numerical matrix. It is stored in the par(0).fit. ; Matrix dimensions are equal to the fitted region (xwin1:xwin2, ywin1:ywin2) defined by windowcenter +- dmax;; Added: It returns also the covariance matrix between the fitted parameters. Covariance matrix stored in the par(0).cov_matrix;; Added a keyword WEIGHT. If setted it is assumed that we are in Photon Noise regime and at each pixel it associates the error equal to square root of signal.; At moment the WEIGHT is equal to 1/abs(<flux in pixel);; If the subima im1 has its minimum less than zero then add a small constant value to have all positive values;; PA unconstrained when fitted. -> to be fixed to proper values.;; Added: Keyword Backfit to control the polynomial degree of the background. If it is active it use a second-order polynomial function;; Added: Keyword Perr to control if error on fitting should be computed or not;; Added: Keyword to save the fitted background only ;; KEYWORD :	Backgfit	-	Define the order of the polynomial used to fit the background;		Weight		-	;		Posback		-	;		Perr		-; ISSUES:;; COVARIANCE MATRIX SAVED ONLY IN FIRST PAR (?)xdmax=dmax(0)ydmax=dmax(1)windowcenter=nearint(windowcenter)xwin1=max([nearint(windowcenter(0))-xdmax,1])xwin2=min([nearint(windowcenter(0))+xdmax,n_elements(im(*,0))-1])ywin1=max([nearint(windowcenter(1))-ydmax,1])ywin2=min([nearint(windowcenter(1))+ydmax,n_elements(im(0,*))-1])im1 = im(xwin1:xwin2,ywin1:ywin2)if keyword_set(rmsmap) then begin	rmsmapsou = rmsmap(xwin1:xwin2,ywin1:ywin2)	checkzerorms = where(rmsmapsou eq 0, ncheckzerorms)	if ncheckzerorms gt 0 then rmsmapsou(checkzerorms) = 1E9	endifif NOT keyword_SET(backgfit) then begin 	;print, "Fitting sources adopting a plane approximation for the background"	bck = 0	par=replicate({ f0:0.d0, x0:0.d0, y0:0.d0, sx:0.d0, sy:0.d0, pa:0.d0, $	error_x0:0.d0, error_y0:0.d0, error_f0:0.d0, error_sx:0.d0, error_sy:0.d0, error_pa:0.d0,$	back:0.d0, backx:0.d0, backy:0.d0, $	error_back:0.d0, error_backx:0.d0, error_backy:0.d0, shift:0.d0, $	sum2res:0.d0, chi2opp:0.d0, chi2:0.d0, dof:0.d0,  status:0.d0, size_flag:' ', nnan: 0., $	fit:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), backgr:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), $;	x2d:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), y2d:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))),$;	x452d:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), y452d:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))),$;	x2dbck:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), y2dbck:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))),$;	x452dbck:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), y452dbck:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))),$	xd2det:0.d0, yd2det:0.d0, x45d2det:0.d0, y45d2det:0.d0,xd2phot:0.d0, yd2phot:0.d0, x45d2phot:0.d0, y45d2phot:0.d0,$	xd2detbck:0.d0, yd2detbck:0.d0, x45d2detbck:0.d0, y45d2detbck:0.d0,xd2photbck:0.d0, yd2photbck:0.d0, x45d2photbck:0.d0, y45d2photbck:0.d0,$	cov_matrix:dblarr(3+6*ngaussians,3+6*ngaussians)},ngaussians)endif else begin	;print, "Fitting sources adopting a second order polynomial approximation for the background"	bck = 3	par=replicate({ f0:0.d0, x0:0.d0, y0:0.d0, sx:0.d0, sy:0.d0, pa:0.d0, $	error_x0:0.d0, error_y0:0.d0, error_f0:0.d0, error_sx:0.d0, error_sy:0.d0, error_pa:0.d0, $	back:0.d0, backx:0.d0, backy:0.d0, backxy:0.d0, backx2:0.d0, backy2:0.d0, $	error_back:0.d0, error_backx:0.d0, error_backy:0.d0, error_backxy:0.d0, error_backx2:0.d0, error_backy2:0.d0, $	shift:0.d0, sum2res:0.d0, chi2opp:0.d0, chi2:0.d0, dof:0.d0, status:0.d0, size_flag:' ',  nnan: 0., $	fit:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))),backgr:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), $;	x2d:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), y2d:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))),$;	x452d:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), y452d:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))),$;	x2dbck:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), y2dbck:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))),$;	x452dbck:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))), y452dbck:fltarr(n_elements(im1(*,0)),n_elements(im1(0,*))),$	xd2det:0.d0, yd2det:0.d0, x45d2det:0.d0, y45d2det:0.d0,xd2phot:0.d0, yd2phot:0.d0, x45d2phot:0.d0, y45d2phot:0.d0,$	xd2detbck:0.d0, yd2detbck:0.d0, x45d2detbck:0.d0, y45d2detbck:0.d0,xd2photbck:0.d0, yd2photbck:0.d0, x45d2photbck:0.d0, y45d2photbck:0.d0,$	cov_matrix:dblarr(6+6*ngaussians,6+6*ngaussians)},ngaussians)endelseparinfo=replicate({fixed:0., limited:[0,0], limits:[0.,0.], tied:'', value:0., mpside:2, relstep:0., mpminstep:0., mpmaxstep:0.}, 3 + bck + 6*(ngaussians))if KEYWORD_SET(posback) then begin	parinfo(0).limited=[1,0]    parinfo(0).limits(0)=0.endifx = im1 & for k=0,n_elements(im1(*,0))-1 do x(k,*)=float(k)y = im1 & for k=0,n_elements(im1(0,*))-1 do y(*,k)=float(k)if keyword_set(mask) then begin	rms_err = mask.mask endif else begin 	rms_err = fltarr(1+2*xdmax,1+2*ydmax)	rms_err(*,*) = 1.endelse;print, "Dmax", dmax;print, "Drange", drange;print, "Windowcenter", windowcenter;print, "Center", center;print, "Source_par", source_paroffset = 0.if min(im1) le 0. then begin 	offset = min(im1)	im1 = im1 + ABS(min(im1)) + 1E-4endif;print, min(im1)im1_ = im1;indices = where(im1 le median(im1));indices = where(im1 lt mean(im1)/2.)if keyword_set(mask) then begin 	indices=where(mask.maskbck eq 1e5, cout,COMPLEMENT=nnindices,NCOMPLEMENT=nnnindices)	okpix = where(mask.mask eq 1 and FINITE(im1) eq 1)		;CHECK THIS. Putted a cicle if	;PRINT, "USING MASK FILE"	;print, "COUT", cout	if cout ne 0 then begin		wheretomulti, im1_, indices, colu, row		im1_(colu, row) = !VALUES.F_NAN	endif;endif ; If there are NAN in the im1 it seems that MPFIT2DFUN won't work properly and will stop ; after one iteration. To fix this issue I replace the NAN with a 0 and put in the rms_err; a value very big 1E9 for such pixelnanposim1 = where(FINITE(im1) eq 0, nnanposim1, complement=nnnanposim1, ncomplement=nnnnanposim1)if nnanposim1 gt 0 then begin		im1(nanposim1) = 0.	rms_err(nanposim1) = 1E9	par(0).nnan = nnanposim1	endif; THIS PART IS TO TAKE INTO ACCOUNT OF THE RMS MAP ONCE WE WILL HAVE THEMif keyword_set(rmsmap) then begin		rms_err = rms_err*rmsmapsou	endifif keyword_set(weight) then begin	rms_weight = im1	if nnanposim1 gt 0 then rms_weight(nanposim1) = 1.	rms_err = rms_weight*rms_errendif;stopif KEYWORD_SET(backgfit) then begin   p_im = mpfit_plane_points(im1_, /HIGH, quiet=quiet);endif else p_im = mpfit_plane(im1_, quiet=quiet)endif else p_im = mpfit_plane_points(im1_, quiet=quiet); For DEBUGGING PURPOSE;; window, 9, XPOS=0, YPOS=500, XS=400, YS=400, TITLE='MASK'; surface, mask.mask; window, 10, XPOS=400, YPOS=500, XS=400, YS=400, TITLE='MASK BCK'; surface, mask.maskbck; surface, im1_;window, 11, XPOS=800, YPOS=500, XS=400, YS=400, TITLE='PLANE GUESS';surface, p_im.planefor ng=1,ngaussians do begin	parinfo(3 + bck + 6*(ng-1)).limited=[1,0] 	; LIMITING THE PEAK FLUX FOR EACH GAUSSIAN TO NOT BE NEGATIVE	parinfo(3 + bck + 6*(ng-1)).limits(0)=0.		if (ngaussians eq 1) then begin  		parinfo(4 + bck).limited=[1,1]	;	LIMITING THE OFFSET FOR THE CENTER OF THE GAUSSIAN  		parinfo(5 + bck).limited=[1,1]	;				;print, "SOURCE_PAR 3 ", source_par(3)							parinfo(6 + bck).limited=[max([source_par(3),0]),max([source_par(3),0])]	;LIMITING SIZE VARIATION USING THE PSF_LIM VALUES		parinfo(7 + bck).limited=[max([source_par(3),0]),max([source_par(3),0])]				
			; 2014/09/03 psf --> 0.95*psf		parinfo(6 + bck).limits=[max([source_par(0)*psf_lim(0), 0.95*psf]),source_par(0)*psf_lim(1)]/2.354		parinfo(7 + bck).limits=[max([source_par(1)*psf_lim(0), 0.95*psf]),source_par(1)*psf_lim(1)]/2.354						;parinfo(6 + bck).limits=source_par(0)*psf_lim/2.354			;parinfo(7 + bck).limits=source_par(1)*psf_lim/2.354					center_ = center								parinfo(4 + bck).limits=[center_(0)-(xwin1)-drange,center_(0)-(xwin1)+drange]		parinfo(5 + bck).limits=[center_(1)-(ywin1)-drange,center_(1)-(ywin1)+drange]				parinfo(0:2).value = [p_im.back,p_im.backx,p_im.backy]				if KEYWORD_SET(backgfit) then begin			backgr_peak = p_im.back + p_im.backx*(center_(0) - (xwin1)) + p_im.backy*(center_(1) - (ywin1)) + $				      p_im.backxy*(center_(0) - (xwin1))*(center_(1) - (ywin1)) + $				      p_im.backy2*(center_(1) - (ywin1))^2 + p_im.backx2*(center_(0) - (xwin1))^2					parinfo(3:5).value = [p_im.backxy, p_im.backx2, p_im.backy2]				endif else begin					backgr_peak = p_im.back + p_im.backx*(center_(0) - (xwin1)) + p_im.backy*(center_(1) - (ywin1))				endelse				peakguess = max([im1(nearint(center_(0) - (xwin1)),nearint(center_(1)- (ywin1))) - backgr_peak,0],pval)				parinfo(3 + bck: 8 + bck).value =[peakguess,center_(0)-(xwin1),center_(1)-(ywin1),source_par(0)/2.354,source_par(1)/2.354,source_par(2)]				if pval eq 1 then begin						parinfo(0:2).value = [0.,0.,0.]						if keyword_set(backgfit) then parinfo(3:5).value = [0.,0.,0.]				endif				;print, "BCKGR_PEAK ", backgr_peak					endif else begin				center_ = reform(center(0, *))		center__ = reform(center(ng - 1,*))		;____________________________________		; TO DEBUG		;print, "CENTER_ SOURCE 0" , center_		;print, "CENTER__  SOURCE ", ng , center__		;____________________________________		parinfo(4 + 6*(ng - 1) + bck).limited=[1,1]  		parinfo(5 + 6*(ng - 1) + bck).limited=[1,1]				parinfo(6 + 6*(ng - 1) + bck).limited=[max([source_par(ng - 1,3),0]),max([source_par(ng - 1,3),0])]		;LIMITING SIZE VARIATION USING THE PSF_LIM VALUES (MULTIPLE SOURCES CASE)		parinfo(7 + 6*(ng - 1) + bck).limited=[max([source_par(ng - 1,3),0]),max([source_par(ng - 1,3),0])]		parinfo(4 + 6*(ng - 1) + bck).limits=[center__(0)-(xwin1)-drange(ng-1),center__(0)-(xwin1)+drange(ng-1)]		parinfo(5 + 6*(ng - 1) + bck).limits=[center__(1)-(ywin1)-drange(ng-1),center__(1)-(ywin1)+drange(ng-1)]
			; 2014/09/03 psf --> 0.95*psf		parinfo(6 + 6*(ng - 1) + bck).limits=[max([source_par(ng - 1,0)*psf_lim(0), 0.95*psf]),source_par(ng - 1, 0)*psf_lim(1)]/2.354		parinfo(7 + 6*(ng - 1) + bck).limits=[max([source_par(ng - 1,1)*psf_lim(0), 0.95*psf]),source_par(ng - 1, 1)*psf_lim(1)]/2.354;		parinfo(6 + 6*(ng - 1) + bck).limits=source_par(ng - 1,0)*psf_lim/2.354;		parinfo(7 + 6*(ng - 1) + bck).limits=source_par(ng - 1,1)*psf_lim/2.354		parinfo(0:2).value = [p_im.back,p_im.backx,p_im.backy]				if KEYWORD_SET (backgfit) then begin					backgr_peak = p_im.back + p_im.backx*(center__(0) - (xwin1)) + p_im.backy*(center__(1) - (ywin1)) + $			p_im.backxy*(center__(0) - (xwin1))*(center__(1) - (ywin1)) + $			p_im.backy2*(center__(1) - (ywin1))^2 + p_im.backx2*(center__(0) - (xwin1))^2					parinfo(3:5).value = [0., 0., 0.]				endif else begin			backgr_peak = p_im.back + p_im.backx*(center__(0) - (xwin1)) + p_im.backy*(center__(1) - (ywin1))				endelse				peakguess = max([im1(nearint(center__(0) - (xwin1)),nearint(center__(1)- (ywin1))) - backgr_peak,0],pval)				parinfo((3 + bck + 6*(ng -1) ):(2 + bck + 6*ng)).value = [peakguess, center__(0)-(xwin1), center__(1)-(ywin1), source_par(ng-1,0)/2.354, source_par(ng-1,1)/2.354, source_par(ng-1,2)]				if pval eq 1 then begin						parinfo(0:2).value = [0.,0.,0.]						if keyword_set(backgfit) then parinfo(3:5).value = [0.,0.,0.]				endif		;		print, "BCKGR_PEAK ", backgr_peak		;				;		for ng_ = 1,ng-1 do begin		 	;			center__ = reform(center((ng_ ),*)) ;		I VERY DON'T LIKE THE TIED CONSTRAINED PART SO I ATTEMPT TO COMMENT IT!; 		  	        if ng gt 1 then begin 	       		        parinfo(4 + 6*(ng -1) + bck).tied="p["+strcompress(string(4+ bck,FORMAT='(I3)'),/REMOVE_ALL)+"]+("+strcompress(string(center__(0)-center_(0)),/remove_all)+")" 		        parinfo(5 + 6*(ng -1) + bck).tied="p["+strcompress(string(5+ bck,FORMAT='(I3)'),/REMOVE_ALL)+"]+("+strcompress(string(center__(1)-center_(1)),/remove_all)+")" 	       	        endif		  	;;		endfor		endelse	endfor;____________________________________________________________________________________________; TO DEBUG;help, PARINFO, /STRUCT;for i = 3,8 do print, "PARINFO", i, " " , parinfo(i).value;if n_elements(parinfo.value) gt 9 then for i = 9,14 do print, "PARINFO", i, " " , parinfo(i).value;if n_elements(parinfo.value) gt 15 then for i = 15,20 do print, "PARINFO", i, " " , parinfo(i).value;if n_elements(parinfo.value) gt 21 then for i = 21,26 do print, "PARINFO", i, " " , parinfo(i).value;print, "BACK ", bck;____________________________________________________________________________________________if KEYWORD_SET(backgfit) then  funct_ = 'multi_funct_back' else funct_ = 'multi_funct';print, "PARINFO", parinfo.limits;print, "PARINFO VALUE", parinfo.value;window, 15;surface, rms_err; MMMMMM??? WHY SHOULD WORK?;rms_err(*,*) = 1.;stopif keyword_set(WEIGHT) then begin; MODIFICATA DA SERGIO 19 AGOSTO 2013	; RIMODIFICATA DA EUGENIO 26 AGOSTO.		wgth=im1 & wgth(*)=1.	for gg = 1, ngaussians do begin			x_vert=fltarr(8) & y_vert=fltarr(8)				; VERIFY ORIENTATION. THERE IS NO REASON IS WRONG BUT I HAVE A FEELING.		   		for vert=0,7 do begin			x_vert(vert)=parinfo(4 + 6*(gg -1) + bck).value+ (cos(parinfo(8 + 6*(gg -1) + bck).value*180./!pi)*parinfo(6 + 6*(gg -1) + bck).value*2.354/2.*cos(vert*!pi/4.))-(sin(parinfo(8 + 6*(gg -1) + bck).value*180./!pi)*parinfo(7 + 6*(gg -1) + bck).value*2.354/2.*sin(vert*!pi/4.))  			y_vert(vert)=parinfo(5 + 6*(gg -1) + bck).value+ (sin(parinfo(8 + 6*(gg -1) + bck).value*180./!pi)*parinfo(6 + 6*(gg -1) + bck).value*2.354/2.*cos(vert*!pi/4.))+(cos(parinfo(8 + 6*(gg -1) + bck).value*180./!pi)*parinfo(7 + 6*(gg -1) + bck).value*2.354/2.*sin(vert*!pi/4.))		endfor						roi=obj_new('IDLanROI',x_vert,y_vert)		tmp_mask=roi->ComputeMask(dimensions=[n_elements(im1[*,0]), n_elements(im1[0,*])])		tmp_mask=FLOAT(tmp_mask/MAX(tmp_mask)*(weight -1))		obj_destroy,roi 	 		wgth = wgth + tmp_mask 	endfor	;	wgth=im1 & wgth(*)=1.;	for gg=1,ngaussians do wgth(nearint(parinfo(4 + 6*(gg -1) + bck).value) -1:nearint(parinfo(4 + 6*(gg -1) + bck).value) +1, nearint(parinfo(5 + 6*(gg -1) + bck).value) -1: nearint(parinfo(5 + 6*(gg -1) + bck).value) +1)=weight	;	wgth = 1./ABS(im1)	if nnanposim1 gt 0 then wgth(nanposim1) = 0.					p=mpfit2dfun(funct_,x,y,im1,rms_err,parinfo=parinfo,maxiter=500,nprint=0, $	FUNCTARGS={ngauss:ngaussians}, COVAR=covar, BESTNORM=bestnorm, PERROR=perror, DOF=dof, $	YFIT=YFIT, WEIGHT=wgth, STATUS=status, quiet=quiet) endif else begin 	if KEYWORD_SET(PERR) then begin	p=mpfit2dfun(funct_,x,y,im1,rms_err,parinfo=parinfo,maxiter=500,nprint=0,$	FUNCTARGS={ngauss:ngaussians}, COVAR=covar, BESTNORM=bestnorm, PERROR=perror, DOF=dof,$	YFIT=YFIT, STATUS=status, quiet=quiet)endif else $	p=mpfit2dfun(funct_,x,y,im1,rms_err,parinfo=parinfo,maxiter=500,nprint=0,$	FUNCTARGS={ngauss:ngaussians}, COVAR=covar, BESTNORM=bestnorm, DOF=dof,$	YFIT=YFIT, STATUS=status, quiet=quiet)endelsefor ng=0,ngaussians-1 do begin	  	par(ng).back  = p(0) + offset - 1E-4  	par(ng).backx = p(1)  	par(ng).backy = p(2)		if KEYWORD_SET(backgfit) then begin				par(ng).backxy = p(3)  		par(ng).backx2 = p(4)	  	par(ng).backy2 = p(5)			endif	;print, "X0 ",  p(4 + bck + 6*ng)	;print, "Y0 ",  p(5 + bck + 6*ng)		par(ng).x0 = p(4 + bck + 6*ng) + xwin1  	par(ng).y0 = p(5 + bck + 6*ng) + ywin1	par(ng).f0 = p(3 + bck + 6*ng)		par(ng).sx = p(6 + bck + 6*ng)	par(ng).sy = p(7 + bck + 6*ng)		if ngaussians eq 1 then begin 				if p(6 + bck + 6*ng) eq parinfo(6 + bck).limits(0) then par(ng).size_flag = par(ng).size_flag+'+XL'		if p(6 + bck + 6*ng) eq parinfo(6 + bck).limits(1) then par(ng).size_flag = par(ng).size_flag+'+XU'		if p(7 + bck + 6*ng) eq parinfo(7 + bck).limits(0) then par(ng).size_flag = par(ng).size_flag+'+YL'		if p(7 + bck + 6*ng) eq parinfo(7 + bck).limits(1) then par(ng).size_flag = par(ng).size_flag+'+YU'				if p(6 + bck + 6*ng) eq 0.95*PSF then par(ng).size_flag = par(ng).size_flag+'+XPSF'		if p(7 + bck + 6*ng) eq 0.95*PSF then par(ng).size_flag = par(ng).size_flag+'+YPSF'	endif else begin			if p(6 + bck + 6*ng) eq parinfo(6 +  6*(ng) + bck).limits(0) then par(ng).size_flag = par(ng).size_flag+'+XL'		if p(6 + bck + 6*ng) eq parinfo(6 +  6*(ng) + bck).limits(1) then par(ng).size_flag = par(ng).size_flag+'+XU'		if p(7 + bck + 6*ng) eq parinfo(7 +  6*(ng) + bck).limits(0) then par(ng).size_flag = par(ng).size_flag+'+YL'		if p(7 + bck + 6*ng) eq parinfo(7 +  6*(ng) + bck).limits(1) then par(ng).size_flag = par(ng).size_flag+'+YU'				if p(6 + bck + 6*ng) eq 0.95*PSF then par(ng).size_flag = par(ng).size_flag+'+XPSF'		if p(7 + bck + 6*ng) eq 0.95*PSF then par(ng).size_flag = par(ng).size_flag+'+YPSF'	endelse			par(ng).pa = p(8 + bck + 6*ng)	if keyword_set(PERR) eq 1 and n_elements(perror) gt 0 then begin			par(ng).error_x0 = perror(4 + bck)		par(ng).error_y0 = perror(5 + bck)		par(ng).error_f0 = perror(3 + bck)		par(ng).error_sx = perror(6 + bck)		par(ng).error_sy = perror(7 + bck)		par(ng).error_pa = perror(8 + bck) 		par(ng).error_back = perror(0)  		par(ng).error_backx = perror(1)  		par(ng).error_backy = perror(2)		if KEYWORD_SET(backgfit) then begin					par(ng).error_backxy = perror(3)  			par(ng).error_backx2 = perror(4)	  		par(ng).error_backy2 = perror(5)			endif	endif else begin		par(ng).error_x0 = -1.0		par(ng).error_y0 = -1.0		par(ng).error_f0 = -1.0		par(ng).error_sx = -1.0		par(ng).error_sy = -1.0		par(ng).error_pa = -1.0				par(ng).error_back = -1.0  		par(ng).error_backx = -1.0  		par(ng).error_backy = -1.0		if KEYWORD_SET(backgfit) then begin					par(ng).error_backxy = -1.0  			par(ng).error_backx2 = -1.0	  		par(ng).error_backy2 = -1.0			endif  	endelse		par(ng).chi2 = bestnorm	par(ng).sum2res = TOTAL((im1(okpix) - yfit(okpix))^2)		par(ng).chi2opp = TOTAL((im1(okpix) - yfit(okpix))^2/(yfit(okpix)))		par(ng).dof = dof	par(ng).status = statusendfor;print, " A = ", par(0).back;print, " B = ", par(0).backx;print, " C = ", par(0).backy;print, " F0 = ", par(0).f0;print, " Sx = ", par(0).sx;print, " Sy = ", par(0).sypar(0).fit = yfitpar(0).cov_matrix = covar; COMPUTING ONLY FITTED BACKGROUNDbackground = im1 background(*,*) = 0.sz = size(im1)for i = 0,sz(1)-1 do begin		for j=0,sz(2)-1 do begin			if keyword_set(backgfit) then begin			background(i,j) = par(0).back + par(0).backx*x(i,j) + par(0).backy*y(i,j) + $			(par(0).backx2*x(i,j)^2 + par(0).backy2*y(i,j)^2 + par(0).backxy*x(i,j)*y(i,j))		endif else background(i,j) = par(0).back + par(0).backx*x(i,j) + par(0).backy*y(i,j)				endforendforpar(0).backgr = background;window, 12, XPOS=0, YPOS=000, XS=400, YS=400, TITLE='FIT';surface, par(0).fit;window, 13, XPOS=400, YPOS=00, XS=400, YS=400, TITLE='IM1';surface, im1;window, 14, XPOS=800, YPOS=00, XS=400, YS=400, TITLE='IM1_';surface, im1_, ZR=!z.crange;; COMPUTING THE DERIVATE IN THE DIFFERENT DIRECTIONS; FOR THE FITTED FUNCTION AND THE BACKGROUND; THE DERIVATE MIGHT HAVE BORDER EFFECTS FOR PIXELS THAT ARE CLOSER TO THE LIMIT OF THE IMAGE THAN 4enlarge_im = dblarr(n_elements(im1(*,0))+8, n_elements(im1(0,*))+8) enlarge_bck = dblarr(n_elements(im1(*,0))+8, n_elements(im1(0,*))+8) xx_ = indgen(n_elements(im1(*,0))+8) - 4 yy_ = indgen(n_elements(im1(0,*))+8) - 4xx = xx_ # (1.0 + FLTARR(n_elements(im1(0,*))+8 ))yy = yy_ ## (1.0 + FLTARR(n_elements(im1(*,0))+8))for i = 0,n_elements(enlarge_im(*,0))-1 do begin		for j=0,n_elements(enlarge_im(0,*))-1 do begin			if keyword_set(backgfit) then begin			enlarge_im(i,j) = par(0).back + par(0).backx*xx(i,j) + par(0).backy*yy(i,j) + $			(par(0).backx2*xx(i,j)^2 + par(0).backy2*yy(i,j)^2 + par(0).backxy*xx(i,j)*yy(i,j))			enlarge_bck(i,j) = par(0).back + par(0).backx*xx(i,j) + par(0).backy*yy(i,j) + $			(par(0).backx2*xx(i,j)^2 + par(0).backy2*yy(i,j)^2 + par(0).backxy*xx(i,j)*yy(i,j))				endif else begin			enlarge_im(i,j) = par(0).back + par(0).backx*xx(i,j) + par(0).backy*yy(i,j)			enlarge_bck(i,j) = par(0).back + par(0).backx*xx(i,j) + par(0).backy*yy(i,j)		endelse		endforendforenlarge_im(4:n_elements(enlarge_im(*,0))-1-4,4:n_elements(enlarge_im(0,*))-1-4) = yfitdummy = fit_deriv(enlarge_im)x2d = dummy.xd2(4:n_elements(enlarge_im(*,0))-1-4,4:n_elements(enlarge_im(0,*))-1-4)y2d = dummy.yd2(4:n_elements(enlarge_im(*,0))-1-4,4:n_elements(enlarge_im(0,*))-1-4)x452d = dummy.x45d2(4:n_elements(enlarge_im(*,0))-1-4,4:n_elements(enlarge_im(0,*))-1-4)y452d = dummy.y45d2(4:n_elements(enlarge_im(*,0))-1-4,4:n_elements(enlarge_im(0,*))-1-4)dummybck = fit_deriv(enlarge_bck)x2dbck = dummybck.xd2(4:n_elements(enlarge_im(*,0))-1-4,4:n_elements(enlarge_im(0,*))-1-4)y2dbck = dummybck.yd2(4:n_elements(enlarge_im(*,0))-1-4,4:n_elements(enlarge_im(0,*))-1-4)x452dbck = dummybck.x45d2(4:n_elements(enlarge_im(*,0))-1-4,4:n_elements(enlarge_im(0,*))-1-4)y452dbck = dummybck.y45d2(4:n_elements(enlarge_im(*,0))-1-4,4:n_elements(enlarge_im(0,*))-1-4)for ng=1,ngaussians do begin	if (ngaussians eq 1) then begin				dummycenter_ = center				xpos = nearint(dummycenter_(0)-(xwin1))		ypos = nearint(dummycenter_(1)-(ywin1))	    		par(0).xd2det = x2d(xpos,ypos)		par(0).yd2det = y2d(xpos,ypos)		par(0).x45d2det = x452d(xpos,ypos)		par(0).y45d2det = y452d(xpos,ypos)		par(0).xd2detbck = x2dbck(xpos,ypos)		par(0).yd2detbck = y2dbck(xpos,ypos)		par(0).x45d2detbck = x452dbck(xpos,ypos)		par(0).y45d2detbck = y452dbck(xpos,ypos)				xposfit = nearint(par(0).x0 - (xwin1))		yposfit = nearint(par(0).y0- (ywin1)); adding a crosscheck on fitted position - we found that sources too close to the border introduce some issues				if (xposfit ge 0 and xposfit le n_elements(x2d[*,0])-1) and (yposfit ge 0 and yposfit le n_elements(x2d[0,*])-1) then begin 							par(0).xd2phot = x2d(xposfit,yposfit)		par(0).yd2phot = y2d(xposfit,yposfit)		par(0).x45d2phot = x452d(xposfit,yposfit)		par(0).y45d2phot = y452d(xposfit,yposfit)		par(0).xd2photbck = x2dbck(xposfit,yposfit)		par(0).yd2photbck = y2dbck(xposfit,yposfit)		par(0).x45d2photbck = x452dbck(xposfit,yposfit)		par(0).y45d2photbck = y452dbck(xposfit,yposfit)				endif else begin								par(0).xd2phot = 0.			par(0).yd2phot = 0.			par(0).x45d2phot = 0.			par(0).y45d2phot =0.				par(0).xd2photbck = 0.			par(0).yd2photbck = 0.			par(0).x45d2photbck = 0.			par(0).y45d2photbck = 0.						endelse		endif else begin			dummycenter__ = reform(center(ng - 1,*))			    xpos = nearint(dummycenter__(0)-(xwin1))	    ypos = nearint(dummycenter__(1)-(ywin1))				if xpos lt n_elements(x2d(*,0)) and ypos lt n_elements(x2d(0,*)) then begin					par(ng-1).xd2det = x2d(xpos,ypos)			par(ng-1).yd2det = y2d(xpos,ypos)			par(ng-1).x45d2det = x452d(xpos,ypos)			par(ng-1).y45d2det = y452d(xpos,ypos)					par(ng-1).xd2detbck = x2dbck(xpos,ypos)			par(ng-1).yd2detbck = y2dbck(xpos,ypos)			par(ng-1).x45d2detbck = x452dbck(xpos,ypos)			par(ng-1).y45d2detbck = y452dbck(xpos,ypos)				endif else begin					par(ng-1).xd2det = 0.			par(ng-1).yd2det = 0.			par(ng-1).x45d2det = 0.			par(ng-1).y45d2det = 0.					par(ng-1).xd2detbck = 0.			par(ng-1).yd2detbck = 0.			par(ng-1).x45d2detbck = 0. 			par(ng-1).y45d2detbck = 0.				endelse						xposfit = nearint(par(ng-1).x0-(xwin1))		yposfit = nearint(par(ng-1).y0-(ywin1))			if xposfit lt n_elements(x2d(*,0)) and yposfit lt n_elements(x2d(0,*)) and xposfit gt 0 and yposfit gt 0 then begin					par(ng-1).xd2phot = x2d(xposfit,yposfit)			par(ng-1).yd2phot = y2d(xposfit,yposfit)			par(ng-1).x45d2phot = x452d(xposfit,yposfit)			par(ng-1).y45d2phot = y452d(xposfit,yposfit)			par(ng-1).xd2photbck = x2dbck(xposfit,yposfit)			par(ng-1).yd2photbck = y2dbck(xposfit,yposfit)			par(ng-1).x45d2photbck = x452dbck(xposfit,yposfit)			par(ng-1).y45d2photbck = y452dbck(xposfit,yposfit)		endif else begin			par(ng-1).xd2phot = 0.			par(ng-1).yd2phot = 0.			par(ng-1).x45d2phot = 0.			par(ng-1).y45d2phot = 0.			par(ng-1).xd2photbck = 0.			par(ng-1).yd2photbck = 0.			par(ng-1).x45d2photbck = 0.			par(ng-1).y45d2photbck = 0.				endelse					endelse	endfor	;stopreturn,parend
